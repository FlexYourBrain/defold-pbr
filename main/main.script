local C = require 'main/constants'

function make_irradiance_texture(path, w, h)
	local targs = {
		type   = resource.TEXTURE_TYPE_CUBE_MAP,
		width  = w,
		height = h,
		format = resource.TEXTURE_FORMAT_RGBA32F
	}

	local tex_path = resource.create_texture("/pbr-irradiance.texturec", targs)
	local data = resource.load(path)

	resource.set_texture(tex_path, targs, data)

	return tex_path
end

function make_prefilter_texture(path, w, h, mipmaps)
	local targs = {
		type        = resource.TEXTURE_TYPE_CUBE_MAP,
		width       = w,
		height      = h,
		format      = resource.TEXTURE_FORMAT_RGBA32F,
		max_mipmaps = mipmaps
	}

	local tex_path = resource.create_texture("/pbr-prefilter.texturec", targs)
	local slice_width = w
	local slice_height = h

	for i = 0, mipmaps-1 do
		local slice_path = path .. "_mm_" .. i .. ".bin"
		local data       = resource.load(slice_path)
		targs.mipmap     = i
		targs.width      = slice_width
		targs.height     = slice_height
		resource.set_texture(tex_path, targs, data)
		slice_width  = slice_height / 2
		slice_height = slice_height / 2
	end

	return tex_path
end

function make_brdf_lut(path, w, h)
	local targs = {
		type   = resource.TEXTURE_TYPE_2D,
		width  = w,
		height = h,
		format = resource.TEXTURE_FORMAT_RGBA32F
	}

	local tex_path = resource.create_texture("/pbr-brdf-lut.texturec", targs)
	local data     = resource.load(path)

	resource.set_texture(tex_path, targs, data)

	return tex_path
end

function init(self)
	msg.post(".", "acquire_input_focus")
	msg.post("@render:", "use_camera_projection")
	msg.post("camera", "acquire_camera_focus")
	msg.post("#preview", "load")

	self.pbr_irradiance_texture = make_irradiance_texture("/defold-pbr/assets/irradiance.bin", 64, 64)
	self.pbr_prefilter_texture  = make_prefilter_texture("/defold-pbr/assets/prefilter", 256, 256, 9)
	self.pbr_brdf_lut           = make_brdf_lut("/defold-pbr/assets/brdf_lut.bin", 512, 512)

	self.pbr_params = {
		camera             = {},
		irradiance_texture = resource.get_texture(self.pbr_irradiance_texture),
		prefilter_texture  = resource.get_texture(self.pbr_prefilter_texture),
		brdf_lut           = resource.get_texture(self.pbr_brdf_lut),
	}
	
	local key_light_qdir = vmath.quat(
		-0.3535534,
		-0.353553385,
		-0.146446586,
		0.8535534)

	local fill_light_qdir = vmath.quat(
		-0.8535534,
		0.146446645,
		-0.353553325,
		-0.353553444)

	local key_light_dir = vmath.rotate(key_light_qdir, vmath.vector3(0,0,-1))
	local fill_light_dir = vmath.rotate(fill_light_qdir, vmath.vector3(0,0,-1))

	msg.post("@render:", "add_light", {
		position  = vmath.vector3(),
		direction = vmath.normalize(key_light_dir),
		color     = vmath.vector3(1,0.5,0),
		intensity = 1,
		type      = C.LIGHT_TYPE.DIRECTIONAL
	})
	msg.post("@render:", "add_light", {
		position  = vmath.vector3(),
		direction = vmath.normalize(fill_light_dir),
		color     = vmath.vector3(1,0.5,0),
		intensity = 0.5,
		type      = C.LIGHT_TYPE.DIRECTIONAL
	})
end

function update(self, dt)
	self.pbr_params.camera.world = go.get_world_position("/camera")
	msg.post("@render:", "set_pbr_params", self.pbr_params)
end

function on_message(self, message_id, message, sender)
	if message_id == hash("proxy_loaded") then
		msg.post(sender, "init")
		msg.post(sender, "enable")
	end
end